## 排序、二分查找、异或运算、栈和队列

### 用master公式来估计时间复杂度
Master 公式：  
形如 T(N) = a * T(N/b) + O(N^d) （a、b、d都是常数）的递归函数，可以直接通过 Master 公式来确定时间复杂度
- 如果 log(b,a) < d, 复杂度为 O(N^d)
- 如果 log(b,a) > d, 复杂度为 O(N^log(b,a))
- 如果 log(b,a) == d, 复杂度为 O(N^d * logN)

### 堆 和 加强堆
[堆相关](../../../java/data_struct/ds1_堆)

### 排序算法总结

|          | 时间复杂度 | 额外空间复杂度 | 稳定性 |
| -------- | ---------- | -------------- | ------ |
| 选择排序 | O(N^2)     | O(1)           | 无     |
| 冒泡排序 | O(N^2)     | O(1)           | 有     |
| 插入排序 | O(N^2)     | O(1)           | 有     |
| 归并排序 | O(NxlogN)  | O(N)           | 有     |
| 随机快排 | O(NxlogN)  | O(logN)        | 无     |
| 堆排序   | O(NxlogN)  | O(1)           | 无     |
| ===      | ===        | ===            | ===    |
| 计数排序 | O(N)       | O(1)           | 有     |
| 基数排序 | O(N)       | O(1)           | 有     |

1)不基于比较的排序，对样本数据有严格要求，不易改写  
2)基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用  
3)基于比较的排序，时间复杂度的极限是O(N*logN)  
4)时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的  
排序是不存在的。  
5)为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并  

