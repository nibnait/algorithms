## 从暴力递归 到动态规划。练！

### [Code01_RobotWalk](./c0700_动态规划/Code01_RobotWalk.java)
假设 有排成一行的N个位置记为1-N，N一定大于或等于2    
开始时机器人在其中的M位置上(M一定是1-N中的一个)    
如果机器人来到1位置，那么下一步只能往右来到2位置；    
如果机器人来到N位置，那么下一步只能往左来到N-1位置；    
如果机器人来到中间位置，那么下一步可以往左走或者往右走；    
规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个)的方法有多少种    
给定四个参数 N、M、K、P，返回方法数    

### [Code02_CardsInLine](./c0700_动态规划/Code02_CardsInLine.java)
给定一个整型数组arr，代表数值不同的纸牌排成一条线    
玩家A和玩家B依次拿走每张纸牌    
规定玩家A先拿，玩家B后拿    
但是每个玩家每次只能拿走最左或最右的纸牌    
玩家A和玩家B都绝顶聪明    
请返回最后获胜者的分数  

### [Code03_Knapsack](./c0700_动态规划/Code03_Knapsack.java)
背包问题  
给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表 i号物品的重量和价值  
给定一个正数bag，表示一个载重bag的袋子，装的物品不能超过这个重量  
返回能装下的最大价值  

### [Code04_ConvertToLetterString](./c0700_动态规划/Code04_ConvertToLetterString.java)
规定1和A对应、2和B对应、3和C对应...26和Z对应  
那么一个数字字符串比如"111”就可以转化为:  
"AAA"、"KA"和"AK"  
给定一个只有数字字符组成的字符串str，返回有多少种转化结果  

### [Code05_StickersToSpellWord](./c0700_动态规划/Code05_StickersToSpellWord.java)
给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文  
arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来  
返回需要至少多少张贴纸可以完成这个任务  
例子：target= "babac"，stickers = {"ba","c","abcd"}  
ba + ba + c  3  
abcd + abcd 2  
abcd+ba 2  
所以返回2  

### [Code06_LongestCommonSubsequence](./c0700_动态规划/Code06_LongestCommonSubsequence.java)
给定两个字符串str1和str2，  
返回这两个字符串的最长公共子序列长度  
比如 ： str1 = “a12b3c456d”,str2 = “1ef23ghi4j56k”  
最长公共子序列是“123456”，所以返回长度6  

### [Code07_PalindromeSubsequence](./c0700_动态规划/Code07_PalindromeSubsequence.java)
给定一个字符串str，返回这个字符串的最长回文子序列长度  
比如 ： str = “a12b3c43def2ghi1kpm”  
最长回文子序列是“1234321”或者“123c321”，返回长度7

### [Code08_HorseJump](./c0700_动态规划/Code08_HorseJump.java)
*WIP: 优化 -> 二维*

请同学们自行想象一个象棋的棋盘，  
然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置  
那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域  
给你三个 参数 x，y，k  
返回“马”从(0,0)位置出发，必须走k步  
最后落在(x,y)上的方法数有多少种?   

### ⭐️ [Code09_Coffee](./c0700_动态规划/Code09_Coffee.java)
给定一个数组arr，arr[i]代表第i号咖啡机泡一杯咖啡的时间  
给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡  
只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯  
每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发  
假设所有人拿到咖啡之后立刻喝干净，  
返回从开始等到所有咖啡机变干净的最短时间  
三个参数：int[] arr、int N，int a、int b

### [Code10_MinPathSum](./c0700_动态规划/Code10_MinPathSum.java)
*WIP: 优化 -> 一维*

给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角  
沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和  
返回最小距离累加和  

### [Code11_CoinsWayEveryPaperDifferent](./c0700_动态规划/Code11_CoinsWayEveryPaperDifferent.java)
*WIP: 优化 -> 一维*

arr是货币数组，其中的值都是正数。再给定一个正数aim。  
每个值都认为是一张货币，  
即便是值相同的货币也认为每一张都是不同的，  
返回组成aim的方法数  
例如：arr = {1,1,1}，aim = 2  
第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2  
一共就3种方法，所以返回3  

### [Code12_CoinsWayNoLimit](./c0700_动态规划/Code12_CoinsWayNoLimit.java)
arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。  
每个值都认为是一种面值，且认为**张数是无限的**。  
返回组成aim的方法数  
例如：arr = {1,2}，aim = 4  
方法如下：1+1+1+1、1+1+2、2+2  
一共就3种方法，所以返回3  

### [Code13_CoinsWaySameValueSamePapper](./c0700_动态规划/Code13_CoinsWaySameValueSamePapper.java)
*WIP: 优化 -> 一维*

arr是货币数组，其中的值都是正数  
每个值都认为是一张货币，  
认为值相同的货币没有任何不同，  
返回组成aim的方法数  
例如：arr = {1,2,1,1}，aim = 4  
方法：1+1+2  
一共就1种方法，所以返回1  

### [Code14_MinCoinsNoLimit](./c0700_动态规划/Code14_MinCoinsNoLimit.java)
arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。  
每个值都认为是一种面值，且认为张数是无限的。  
返回组成aim的最少货币数  

### [Code15_BobDie](./c0700_动态规划/Code15_BobDie.java)
*WIP: 优化 -> 一维*

给定5个参数，N，M，row，col，k  
表示在N*M的区域上，醉汉Bob初始在(row,col)位置  
Bob一共要迈出k步，且每步都会等概率向上下左右四个方向走一个单位  
任何时候Bob只要离开N*M的区域，就直接死亡  
返回k步之后，Bob还在N*M的区域的概率  

### [Code16_KillMonster](./c0700_动态规划/Code16_KillMonster.java)
给定3个参数，N，M，K  
怪兽有N滴血，等着英雄来砍自己  
英雄每一次打击，都会让怪兽流失[0~M]的血量  
到底流失多少？每一次在[0~M]上等概率的获得一个值  
求K次打击之后，英雄把怪兽砍死的概率  

### [Code17_SplitNumber](./c0700_动态规划/Code17_SplitNumber.java)
给定一个正数n，求n的裂开方法数，  
规定：后面的数不能比前面的数小  
比如4的裂开方法有：  
1+1+1+1、1+1+2、1+3、2+2、4  
5种，所以返回5

### [Code18_SplitSumClosed](./c0700_动态规划/Code18_SplitSumClosed.java)
给定一个正数数组arr，  
请把arr中所有的数分成两个集合，尽量让两个集合的累加和接近  
返回最接近的情况下，较小集合的累加和

### [Code19_SplitSumClosedSizeHalf](./c0700_动态规划/Code19_SplitSumClosedSizeHalf.java)
给定一个正数数组arr，请把arr中所有的数分成两个集合  
如果arr长度为偶数，两个集合包含数的个数要一样多  
如果arr长度为奇数，两个集合包含数的个数必须只差一个  
请尽量让两个集合的累加和接近  
返回最接近的情况下，较小集合的累加和   

### [Code20_NQueens](./c0700_动态规划/Code20_NQueens.java)
N皇后问题是指在N*N的棋盘上要摆N个皇后，  
要求任何两个皇后不同行、不同列， 也不在同一条斜线上  
给定一个整数n，返回n皇后的摆法有多少种。n=1，返回1  
n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0  
n=8，返回92  
