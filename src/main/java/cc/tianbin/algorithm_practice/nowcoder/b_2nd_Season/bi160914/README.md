课程回顾：[http://www.Algorithm.algorithm_practice.nowcoder.com/live/11/9/1](http://www.nowcoder.com/live/11/9/1)
课件下载：[https://pan.baidu.com/s/1kVk7k71](https://pan.baidu.com/s/1kVk7k71)


## 题目一： 在二叉树中找到一个结点的后继结点
【题目】  
现在有一种新的二叉树结点类型如下：

    public class Node {
        public int value;
        public Node left;
        public Node right;
        public Node parent;
    
        public Node(int data) {
            this.value = data;
        }
    }

该结构比普通二叉树结点结构多了一个指向父结点的parent指针。假设有一棵Node类型的结点组成的二叉树，树中每个结点的parent指针都正确地指向自己的父结点，头结点的parent指向null。只给二叉树中的某个结点node，请实现返回node的后继结点的函数。
后继结点：在二叉树的中序遍历的序列中，node的下一个结点叫作node的后继结点。

    《剑指Offer》 h58_二叉树的下一个结点：

    【解】：（此题有指向父结点的指针，极大的降低了难度，不然你还得先 先序遍历一些这棵树，把达到此结点的路径记录下来）
       要寻找中序遍历二叉树的下一个结点，
       1. 此结点有右子树，则其下一个结点为：其右子树上的最左结点
       2. 没有右子树，
            - 他是他爸爸的左孩子，那么他的下一个结点就是他的爸爸
            - 他是他爸爸的右孩子，他自己还没有右子树：这时我们就要向上找了，直到根结点或者此结点是他爸爸的右孩子（$_$ 语文不好，这个只能你自己画图体会了）
               


## 题目二： 遍历二叉树的神级方法
【题目】  
给定一棵二叉树的头结点head，完成二叉树的先序、中序和后序遍历。

【要求】  
如果二叉树的结点数为N，要求时间复杂度为O(N)，额外空间复杂度为O(1)。

    Morris遍历，时间复杂度是O(1)：使用二叉树结点中大量的指向null的指针。
    
    中序：
    先看当前结点的左子树的最右结点
        如果指向空：需要将其的right->他自己，当前node向左移动。
        当前结点没有左子树或者 已经指向他自己：将其的right->null，并打印当前node结点。向右移动
        
    先序：
    先看当前结点的左子树的最右结点
        如果指向空：需要将其的right->他自己，并打印当前node结点。当前node向左移动。
        当前结点没有左子树或者 已经指向他自己：将其的right->null，向右移动
        
    后序：
    先看当前结点的左子树的最右结点
        如果指向空：需要将其的right->他自己，当前node向左移动。
        当前结点没有左子树或者 已经指向他自己：将其的right->null，并打印当前node的左子树的右边界，向右移动
        最后，再打印当前左子树树的整个右边界的逆序
        逆序：调整链表的方式，即将这个右边界的链表逆序。打印完毕再给他调回去。 √
    整棵树的后序遍历结点：从左到右，所有子树的右边界的逆序。
![bi16091401](../../image/nowcoderbi16091401.png)
  
    
    
    
## 题目三： 找到二叉树中符合搜索二叉树条件的最大拓扑结构
【题目】  
给定一棵二叉树的头结点head，已知所有结点的值都不一样，返回其中最大的、且符合搜索二叉树条件的拓扑结构的结点数。
这里的拓扑结构是指，你可以在二叉树中任意选择某些结点，只要这些结点是连在一起的，都叫做二叉树的拓扑结构。
    
    最大拓扑结构：
    
    一个新的概念：拓扑贡献：
                3
               / \
              1   4
             /\
            0  2
         0的拓扑贡献：（0, 0），必须以"3"为头结点，
                            "0" 的左子树能为"3"为头的这棵二叉搜索树贡献0个结点
                            "0" 的右子树能为"3"为头的这棵二叉搜索树贡献0个结点
         2的拓扑贡献：（0，0），必须以"3"为头结点，
                            "2" 的左子树能为"3"为头的这棵二叉搜索树贡献0个结点
                            "2" 的右子树能为"3"为头的这棵二叉搜索树贡献0个结点
         4的拓扑贡献：（0, 0）必须以"3"为头结点，
                            "4" 的左子树能为"3"为头的这棵二叉搜索树贡献0个结点
                            "4" 的右子树能为"3"为头的这棵二叉搜索树贡献0个结点
         1的拓扑贡献：（1，1），必须以"3"为头结点，
                            "1" 的左子树能为"3"为头的这棵二叉搜索树贡献1个结点
                            "1" 的右子树能为"3"为头的这棵二叉搜索树贡献1个结点
         3的拓扑贡献：（3，1），必须以"3"为头结点，
                            "3" 的左子树能为"3"为头的这棵二叉搜索树贡献3个结点（"1"的左：1 + "1"的右：1 + "1"自己：1 = 3）
                            "3" 的右子树能为"3"为头的这棵二叉搜索树贡献1个结点
                             
    然后 以后序遍历的方式 更新各个结点的拓扑贡献
    
    下面分析一下时间复杂度：
        当二叉树越趋近于棒状：其时间复杂度就越趋近于O（N）
        当二叉树越趋近于满二叉树时，其时间复杂度就越趋近于O（N * logN）
        

