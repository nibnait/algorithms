课程回顾：[http://www.Algorithm.algorithm_practice.nowcoder.com/live/11/10/1](http://www.nowcoder.com/live/11/10/1)
课件下载：[http://yun.baidu.com/share/link?shareid=3759269894&uk=1149059393](http://yun.baidu.com/share/link?shareid=3759269894&uk=1149059393)



## 题目一：二叉树的按层打印与ZigZag 打印
【题目】  
给定一棵二叉树的头结点head，分别实现按层打印和ZigZag 打印二叉树的函数。

【例子】  
如果一颗二叉树头结点值为1；第二层为2，3；第三层为4，5，6，7。  
按层打印时，输出格式必须如下：  
Level 1 : 1  
Level 2 : 2 3  
Level 3 : 4 5 6 7  
ZigZag 打印时，输出格式必须如下：  
Level 1 from left to right: 1  
Level 2 from right to left: 3 2  
Level 3 from left to right: 4 5 6 7  

    《剑指Offer》 d23_从上往下打印二叉树：用队列
    《剑指Offer》 h61_按之字形顺序打印二叉树：用栈


## 题目二：判断一棵二叉树是否为搜索二叉树、完全二叉树、平衡二叉树

    平衡二叉树：f39_2$判断二叉树是否平衡（后序遍历，每个结点带上他的深度），然后即可判断此根结点下的左右子树是否平衡了
    完全二叉树：1. 当某个结点（有右无左）没有左孩子，只有右孩子，return false
               2. 当某个结点有左无右：则接下来按层遍历的所有结点 都必须是叶子结点
               3. 当某个结点是叶子结点时，则他后面的结点也必须都是叶子结点
               boolean： leaf，表示是否进入了只有叶结点的阶段
    搜索二叉树：中序遍历，看得到的这个序列是不是升序的
              

## 题目三：调整搜索二叉树中两个错误的结点
【题目】  
一棵二叉树原本是搜索二叉树，但是其中有两个结点调换了位置，使得这棵二叉
树不再是搜索二叉树，请找到这两个错误结点并返回。已知二叉树中所有结点的
值都不一样，给定二叉树的头结点head，返回一个长度为2 的二叉树结点类型
的数组errs，errs[0]表示一个错误结点，errs[1]表示另一个错误结点。
    
    
    因为只有两个结点错了
    
 - 1**4**3**2**5
 - 1**32**45
 
        所以只需 双指针从前往后遍历搜索二叉树的中序序列
        fast记录：第一次出现逆序对的第一个数，
        last记录：最后一次出现逆序对的最后一个数


【进阶】  
如果在原问题中得到了这两个错误结点，我们当然可以通过交换两个结点的结点
值的方式让整棵二叉树重新成为搜索二叉树。但现在要求你不能这么做，而是在
结构上完全交换两个结点的位置，请实现调整的函数。

![bj092801](../../image/nowcoderbj16092801.png)

    1. 1的1p，跟2的2p，交换
    2. 1的左右孩子，跟2的左右孩子 交换
    
    但是：
         2
        /
       1
       1的左指针就会指向他自己了
    同时：1可能没有父、2可能没有父
         1的左孩子有可能是2
         。。。
         。。。



## 题目四：认识布隆过滤器
【题目】  
不安全网页的黑名单包含100 亿个黑名单网页，每个网页的URL 最多占用64B。
现在想要实现一种网页过滤系统，可以根据网页的URL 判断该网页是否在黑名单
上，请设计该系统。

【要求】  
1．该系统允许有万分之一以下的判断失误率。  
2．使用的额外空间不要超过30GB。
  
    100亿个URL * 64B --> 10G * 64
    离散函数： hash()
        1. input： ∞
        2. output：有限的
        3. 相同的输入，输出一定相同
           不同的输入，正常不同，也可能相同
        4. 不同的输入情况下，输出域中的所有值 是均匀增长的 （输出域中每个值被击中的概率是固定的。）
        例： long fun( string )
        
    布隆过滤器：
        bitmap的思想。
        byte[] bitmap = new byte[M];    
        每个byte是8位，将hash之后得到的值 对M取余，然后将对应的bit位的值置为1
        x = hash(str)/8 %M：求出在那个byte中
        byte[x] = 1 << x ：将对应的bit置为1
        所以，失误的情况：宁可错杀三千 也不放过1个。
        （与输入无关，只与hash()出来的输出值 和 布隆过滤器的大小有关）
           
  
  
## 题目五：一致性哈希算法的基本原理
【题目】  
工程师常使用服务器集群来设计和实现数据缓存，以下是常见的策略：  
1．无论是添加、查询还是删除数据，都先将数据的id 通过哈希函数转换成一个哈希值，记为key。  
2．如果目前机器有N 台，则计算key%N 的值，这个值就是该数据所属的机器编号，无论是添加、删除还是查询操作，都只在这台机器上进行。  
请分析这种缓存策略可能带来的问题，并提出改进的方案。

    1. 扩容的时候：加了台机器：
        不采用取模的方式来定位服务器
        而是算完hash，然后 选定顺时针方向离他最近的那台服务器（二分查找）
![bj092802](../../image/nowcoderbj16092802.png)
    
    将C-D段上的数据全部前移到D上即可。
    
    但是这样，当服务器的数量很少的时候，会造成服务器负载不均：
    引入虚拟结点的概念： 
        将A、B两台服务器虚拟出上万个虚拟结点，然后放到环上
        来用一个虚拟路由表 来模拟上万台服务器
    

